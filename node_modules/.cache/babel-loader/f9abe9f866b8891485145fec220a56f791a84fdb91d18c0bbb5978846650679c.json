{"ast":null,"code":"/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {};\n  let single = options_.singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: 'mathText'\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n    let size;\n    /** @type {Token} */\n    let token;\n    return start;\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return sequenceOpen(code);\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code);\n      }\n      effects.exit('mathTextSequence');\n      return between(code);\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return sequenceClose(code);\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return between;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return between;\n      }\n\n      // Data.\n      effects.enter('mathTextData');\n      return data(code);\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = 'mathTextData';\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}","map":{"version":3,"names":["markdownLineEnding","mathText","options","options_","single","singleDollarTextMath","undefined","tokenize","tokenizeMathText","resolve","resolveMathText","previous","name","effects","ok","nok","self","sizeOpen","size","token","start","code","enter","sequenceOpen","consume","exit","between","sequenceClose","data","type","events","tailExitIndex","length","headEnterIndex","index","end","splice"],"sources":["/Users/mac/Documents/Career/Website/node_modules/micromark-extension-math/lib/math-text.js"],"sourcesContent":["/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {};\n  let single = options_.singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: 'mathText'\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n    let size;\n    /** @type {Token} */\n    let token;\n    return start;\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return sequenceOpen(code);\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code);\n      }\n      effects.exit('mathTextSequence');\n      return between(code);\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return sequenceClose(code);\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return between;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return between;\n      }\n\n      // Data.\n      effects.enter('mathTextData');\n      return data(code);\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = 'mathTextData';\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}