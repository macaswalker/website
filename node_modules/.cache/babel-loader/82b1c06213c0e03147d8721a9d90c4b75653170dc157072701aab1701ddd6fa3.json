{"ast":null,"code":"/**\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { ok as assert } from 'devlop';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { codes, constants, types } from 'micromark-util-symbol';\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: 'mathFlow'\n};\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.dollarSign, 'expected `$`');\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit('mathFlowFenceSequence');\n    return factorySpace(effects, metaBefore, types.whitespace)(code);\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit('mathFlowFenceMeta');\n      return metaAfter(code);\n    }\n    if (code === codes.dollarSign) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence');\n    if (self.interrupt) {\n      return ok(code);\n    }\n    return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt({\n      tokenize: tokenizeClosingFence,\n      partial: true\n    }, after, contentStart)(code);\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (initialSize ? factorySpace(effects, beforeContentChunk, types.linePrefix, initialSize + 1) : beforeContentChunk)(code);\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === codes.eof) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentChunk(code);\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    assert(self.parser.constructs.disable.null, 'expected `disable.null`');\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(effects, beforeSequenceClose, types.linePrefix, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize);\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return sequenceClose(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === codes.dollarSign) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok(code);\n      }\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, afterSequenceClose, types.whitespace)(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code);\n    }\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","codes","constants","types","mathFlow","tokenize","tokenizeMathFenced","concrete","name","nonLazyContinuation","tokenizeNonLazyContinuation","partial","effects","nok","self","tail","events","length","initialSize","type","linePrefix","sliceSerialize","sizeOpen","start","code","dollarSign","enter","sequenceOpen","consume","exit","metaBefore","whitespace","eof","metaAfter","chunkString","contentType","contentTypeString","meta","interrupt","attempt","beforeNonLazyContinuation","after","tokenizeClosingFence","contentStart","beforeContentChunk","contentChunk","size","parser","constructs","disable","null","beforeSequenceClose","includes","undefined","tabSize","sequenceClose","afterSequenceClose","lineEnding","lineStart","lazy","now","line"],"sources":["/Users/mac/Documents/Career/Website/node_modules/micromark-extension-math/dev/lib/math-flow.js"],"sourcesContent":["/**\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: 'mathFlow'\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.dollarSign, 'expected `$`')\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, types.whitespace)(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n\n    effects.enter('mathFlowFenceMeta')\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n\n    if (code === codes.dollarSign) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n\n    if (self.interrupt) {\n      return ok(code)\n    }\n\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {tokenize: tokenizeClosingFence, partial: true},\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            types.linePrefix,\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n\n    assert(self.parser.constructs.disable.null, 'expected `disable.null`')\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      types.linePrefix,\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : constants.tabSize\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === codes.dollarSign) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, types.whitespace)(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}