{"ast":null,"code":"/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport { ok as assert } from 'devlop';\nimport { longestStreak } from 'longest-streak';\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  };\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {\n        className: ['language-math', 'math-display']\n      },\n      children: []\n    };\n    this.enter({\n      type: 'math',\n      meta: null,\n      value: '',\n      data: {\n        hName: 'pre',\n        hChildren: [code]\n      }\n    }, token);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node.type === 'math');\n    node.meta = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return;\n    this.buffer();\n    this.data.mathFlowInside = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    const node = this.stack[this.stack.length - 1];\n    assert(node.type === 'math');\n    this.exit(token);\n    node.value = data;\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */node.data.hChildren[0];\n    assert(code.type === 'element');\n    assert(code.tagName === 'code');\n    code.children.push({\n      type: 'text',\n      value: data\n    });\n    this.data.mathFlowInside = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter({\n      type: 'inlineMath',\n      value: '',\n      data: {\n        hName: 'code',\n        hProperties: {\n          className: ['language-math', 'math-inline']\n        },\n        hChildren: []\n      }\n    }, token);\n    this.buffer();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node.type === 'inlineMath');\n    this.exit(token);\n    node.value = data;\n    const children = /** @type {Array<HastElementContent>} */\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    node.data.hChildren;\n    children.push({\n      type: 'text',\n      value: data\n    });\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token);\n    this.config.exit.data.call(this, token);\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  inlineMath.peek = inlineMathPeek;\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      character: '\\n',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      character: '$',\n      after: single ? undefined : '\\\\$',\n      inConstruct: 'phrasing'\n    }, {\n      character: '$',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      atBreak: true,\n      character: '$',\n      after: '\\\\$'\n    }],\n    handlers: {\n      math,\n      inlineMath\n    }\n  };\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || '';\n    const tracker = state.createTracker(info);\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2));\n    const exit = state.enter('mathFlow');\n    let value = tracker.move(sequence);\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta');\n      value += tracker.move(state.safe(node.meta, {\n        after: '\\n',\n        before: value,\n        encode: ['$'],\n        ...tracker.current()\n      }));\n      subexit();\n    }\n    value += tracker.move('\\n');\n    if (raw) {\n      value += tracker.move(raw + '\\n');\n    }\n    value += tracker.move(sequence);\n    exit();\n    return value;\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || '';\n    let size = 1;\n    if (!single) size++;\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)) {\n      size++;\n    }\n    const sequence = '$'.repeat(size);\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n    // Contains non-space.\n    /[^ \\r\\n]/.test(value) && (\n    // Starts with space and ends with space.\n    /^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) ||\n    // Starts or ends with dollar.\n    /^\\$|\\$$/.test(value))) {\n      value = ' ' + value + ' ';\n    }\n    let index = -1;\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index];\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue;\n      const expression = state.compilePattern(pattern);\n      /** @type {RegExpExecArray | null} */\n      let match;\n      while (match = expression.exec(value)) {\n        let position = match.index;\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (value.codePointAt(position) === 10 /* `\\n` */ && value.codePointAt(position - 1) === 13 /* `\\r` */) {\n          position--;\n        }\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n      }\n    }\n    return sequence + value + sequence;\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$';\n  }\n}","map":{"version":3,"names":["ok","assert","longestStreak","mathFromMarkdown","enter","mathFlow","enterMathFlow","mathFlowFenceMeta","enterMathFlowMeta","mathText","enterMathText","exit","exitMathFlow","mathFlowFence","exitMathFlowFence","exitMathFlowMeta","mathFlowValue","exitMathData","exitMathText","mathTextData","token","code","type","tagName","properties","className","children","meta","value","data","hName","hChildren","buffer","resume","node","stack","length","mathFlowInside","replace","push","undefined","hProperties","config","call","mathToMarkdown","options","single","singleDollarTextMath","inlineMath","peek","inlineMathPeek","unsafe","character","inConstruct","after","atBreak","handlers","math","_","state","info","raw","tracker","createTracker","sequence","repeat","Math","max","move","subexit","safe","before","encode","current","size","RegExp","test","index","pattern","expression","compilePattern","match","exec","position","codePointAt","slice"],"sources":["/Users/mac/Documents/Career/Website/node_modules/mdast-util-math/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {ok as assert} from 'devlop'\nimport {longestStreak} from 'longest-streak'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {className: ['language-math', 'math-display']},\n      children: []\n    }\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {hName: 'pre', hChildren: [code]}\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return\n    this.buffer()\n    this.data.mathFlowInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    this.exit(token)\n    node.value = data\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\n    assert(code.type === 'element')\n    assert(code.tagName === 'code')\n    code.children.push({type: 'text', value: data})\n    this.data.mathFlowInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'code',\n          hProperties: {className: ['language-math', 'math-inline']},\n          hChildren: []\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'inlineMath')\n    this.exit(token)\n    node.value = data\n    const children = /** @type {Array<HastElementContent>} */ (\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    )\n    children.push({type: 'text', value: data})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || ''\n    const tracker = state.createTracker(info)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = state.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta')\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: '\\n',\n          before: value,\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index]\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      const expression = state.compilePattern(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}