{"ast":null,"code":"// src/data/blog/interactive-machine-learning-demo.js\nconst post = {\n  id: \"interactive-machine-learning-demo\",\n  title: \"Interactive Machine Learning: From Theory to Practice\",\n  publication: \"Personal Blog, 2025\",\n  date: \"2025-04-20\",\n  summary: \"Explore machine learning concepts with interactive code examples you can run right in your browser.\",\n  content: `\n  # Interactive Machine Learning: From Theory to Practice\n  \n  ## Introduction\n  \n  Machine learning doesn't have to be a black box. In this post, we'll explore some fundamental concepts with interactive examples that you can modify and run directly in your browser.\n  \n  ## Understanding Linear Regression\n  \n  Linear regression is one of the most basic but powerful machine learning algorithms. It attempts to model the relationship between variables by fitting a linear equation to the observed data.\n  \n  \\`\\`\\`javascript\n  // Simple linear regression example\n  const xs = [1, 2, 3, 4, 5];\n  const ys = [2, 4, 5, 4, 5];\n  \n  // Calculate the mean of an array\n  const mean = arr => arr.reduce((a, b) => a + b) / arr.length;\n  \n  // Calculate slope and intercept\n  const xMean = mean(xs);\n  const yMean = mean(ys);\n  const slope = xs.map((x, i) => ({ x, y: ys[i] }))\n                 .reduce((sum, point) => sum + (point.x - xMean) * (point.y - yMean), 0) / \n                 xs.reduce((sum, x) => sum + Math.pow(x - xMean, 2), 0);\n  const intercept = yMean - slope * xMean;\n  \n  console.log(\\`y = \\${slope.toFixed(2)}x + \\${intercept.toFixed(2)}\\`);\n  \n  // Predict values\n  const predictions = xs.map(x => slope * x + intercept);\n  console.log(\"Predictions:\", predictions);\n  \\`\\`\\`\n  \n  ## Interactive Components\n  \n  Let's create a simple interactive slider that demonstrates how changing parameters affects a model:\n  \n  <InteractiveDemo>\n  {() => {\n    const [slope, setSlope] = React.useState(0.8);\n    const [intercept, setIntercept] = React.useState(1);\n    \n    // Sample data points\n    const data = [\n      { x: 1, y: 2 },\n      { x: 2, y: 4 },\n      { x: 3, y: 5 },\n      { x: 4, y: 4 },\n      { x: 5, y: 5 }\n    ];\n    \n    // Calculate predictions and error\n    const predictions = data.map(point => slope * point.x + intercept);\n    const errors = data.map((point, i) => Math.abs(point.y - predictions[i]));\n    const totalError = errors.reduce((sum, err) => sum + err, 0);\n    \n    return (\n      <div className=\"p-4 border border-gray-300 rounded-md bg-gray-50\">\n        <h3 className=\"text-lg font-medium mb-4\">Linear Regression Interactive Demo</h3>\n        \n        <div className=\"mb-4\">\n          <label className=\"block text-sm font-medium mb-1\">\n            Slope: {slope.toFixed(2)}\n          </label>\n          <input\n            type=\"range\"\n            min=\"-2\"\n            max=\"2\"\n            step=\"0.1\"\n            value={slope}\n            onChange={e => setSlope(parseFloat(e.target.value))}\n            className=\"w-full\"\n          />\n        </div>\n        \n        <div className=\"mb-4\">\n          <label className=\"block text-sm font-medium mb-1\">\n            Intercept: {intercept.toFixed(2)}\n          </label>\n          <input\n            type=\"range\"\n            min=\"-5\"\n            max=\"5\"\n            step=\"0.1\"\n            value={intercept}\n            onChange={e => setIntercept(parseFloat(e.target.value))}\n            className=\"w-full\"\n          />\n        </div>\n        \n        <div className=\"mb-4\">\n          <div className=\"h-64 relative border border-gray-300 bg-white\">\n            {/* Coordinate system */}\n            <div className=\"absolute left-0 right-0 bottom-1/2 border-b border-gray-300\"></div>\n            <div className=\"absolute top-0 bottom-0 left-1/2 border-l border-gray-300\"></div>\n            \n            {/* Plot points */}\n            {data.map((point, i) => (\n              <div \n                key={i}\n                className=\"absolute h-2 w-2 bg-blue-500 rounded-full\"\n                style={{ \n                  bottom: \\`\\${(point.y + 5) * 5}%\\`, \n                  left: \\`\\${(point.x + 5) * 5}%\\` \n                }}\n              ></div>\n            ))}\n            \n            {/* Plot line */}\n            <div \n              className=\"absolute h-0.5 bg-red-500 transform origin-left\"\n              style={{ \n                bottom: \\`\\${(intercept + 5) * 5}%\\`, \n                left: '25%',\n                width: '50%',\n                transform: \\`rotate(\\${Math.atan(slope) * (180 / Math.PI)}deg)\\`\n              }}\n            ></div>\n          </div>\n        </div>\n        \n        <div className=\"text-sm\">\n          <p>Equation: y = {slope.toFixed(2)}x + {intercept.toFixed(2)}</p>\n          <p>Total Error: {totalError.toFixed(2)}</p>\n        </div>\n      </div>\n    );\n  }}\n  </InteractiveDemo>\n  \n  ## Advanced Code Example\n  \n  Here's a more complex example showing how to implement a simple neural network for binary classification:\n  \n  \\`\\`\\`javascript\n  class SimpleNeuralNetwork {\n    constructor(inputSize, hiddenSize, outputSize) {\n      // Initialize weights and biases\n      this.weightsInputHidden = Array(inputSize).fill().map(() => \n        Array(hiddenSize).fill().map(() => Math.random() * 2 - 1));\n      this.biasHidden = Array(hiddenSize).fill().map(() => Math.random() * 2 - 1);\n      \n      this.weightsHiddenOutput = Array(hiddenSize).fill().map(() => \n        Array(outputSize).fill().map(() => Math.random() * 2 - 1));\n      this.biasOutput = Array(outputSize).fill().map(() => Math.random() * 2 - 1);\n    }\n    \n    // Sigmoid activation function\n    sigmoid(x) {\n      return 1 / (1 + Math.exp(-x));\n    }\n    \n    // Forward pass\n    predict(inputs) {\n      // Calculate hidden layer outputs\n      const hiddenOutputs = Array(this.biasHidden.length).fill(0);\n      for (let i = 0; i < this.weightsInputHidden.length; i++) {\n        for (let j = 0; j < this.weightsInputHidden[i].length; j++) {\n          hiddenOutputs[j] += inputs[i] * this.weightsInputHidden[i][j];\n        }\n      }\n      \n      for (let i = 0; i < hiddenOutputs.length; i++) {\n        hiddenOutputs[i] = this.sigmoid(hiddenOutputs[i] + this.biasHidden[i]);\n      }\n      \n      // Calculate output layer outputs\n      const outputs = Array(this.biasOutput.length).fill(0);\n      for (let i = 0; i < this.weightsHiddenOutput.length; i++) {\n        for (let j = 0; j < this.weightsHiddenOutput[i].length; j++) {\n          outputs[j] += hiddenOutputs[i] * this.weightsHiddenOutput[i][j];\n        }\n      }\n      \n      for (let i = 0; i < outputs.length; i++) {\n        outputs[i] = this.sigmoid(outputs[i] + this.biasOutput[i]);\n      }\n      \n      return outputs;\n    }\n  }\n  \n  // Example usage\n  const nn = new SimpleNeuralNetwork(2, 3, 1);\n  console.log(\"Prediction for [0, 0]:\", nn.predict([0, 0]));\n  console.log(\"Prediction for [0, 1]:\", nn.predict([0, 1]));\n  console.log(\"Prediction for [1, 0]:\", nn.predict([1, 0]));\n  console.log(\"Prediction for [1, 1]:\", nn.predict([1, 1]));\n  \\`\\`\\`\n  \n  ## Live Code Execution\n  \n  Let's create a component where you can edit and run code directly:\n  \n  <LiveCode initialCode={\n  \\`// Edit and run this code!\n  const data = [1, 2, 3, 4, 5];\n  const doubled = data.map(x => x * 2);\n  const sum = doubled.reduce((a, b) => a + b, 0);\n  console.log(\"Original data:\", data);\n  console.log(\"Doubled:\", doubled);\n  console.log(\"Sum of doubled values:\", sum);\n  \\`}/>\n  \n  ## Conclusion\n  \n  Interactive examples make learning complex concepts much easier. By playing with parameters and seeing results in real-time, you can build intuition for how algorithms work under the hood.\n  \n  Feel free to experiment with the code examples above, modify them, and see what happens!\n    `\n};\nexport default post;","map":{"version":3,"names":["post","id","title","publication","date","summary","content"],"sources":["/Users/mac/Documents/Career/Website/src/data/blog/interactive-machine-learning-demo.js"],"sourcesContent":["// src/data/blog/interactive-machine-learning-demo.js\nconst post = {\n    id: \"interactive-machine-learning-demo\",\n    title: \"Interactive Machine Learning: From Theory to Practice\",\n    publication: \"Personal Blog, 2025\",\n    date: \"2025-04-20\",\n    summary: \"Explore machine learning concepts with interactive code examples you can run right in your browser.\",\n    content: `\n  # Interactive Machine Learning: From Theory to Practice\n  \n  ## Introduction\n  \n  Machine learning doesn't have to be a black box. In this post, we'll explore some fundamental concepts with interactive examples that you can modify and run directly in your browser.\n  \n  ## Understanding Linear Regression\n  \n  Linear regression is one of the most basic but powerful machine learning algorithms. It attempts to model the relationship between variables by fitting a linear equation to the observed data.\n  \n  \\`\\`\\`javascript\n  // Simple linear regression example\n  const xs = [1, 2, 3, 4, 5];\n  const ys = [2, 4, 5, 4, 5];\n  \n  // Calculate the mean of an array\n  const mean = arr => arr.reduce((a, b) => a + b) / arr.length;\n  \n  // Calculate slope and intercept\n  const xMean = mean(xs);\n  const yMean = mean(ys);\n  const slope = xs.map((x, i) => ({ x, y: ys[i] }))\n                 .reduce((sum, point) => sum + (point.x - xMean) * (point.y - yMean), 0) / \n                 xs.reduce((sum, x) => sum + Math.pow(x - xMean, 2), 0);\n  const intercept = yMean - slope * xMean;\n  \n  console.log(\\`y = \\${slope.toFixed(2)}x + \\${intercept.toFixed(2)}\\`);\n  \n  // Predict values\n  const predictions = xs.map(x => slope * x + intercept);\n  console.log(\"Predictions:\", predictions);\n  \\`\\`\\`\n  \n  ## Interactive Components\n  \n  Let's create a simple interactive slider that demonstrates how changing parameters affects a model:\n  \n  <InteractiveDemo>\n  {() => {\n    const [slope, setSlope] = React.useState(0.8);\n    const [intercept, setIntercept] = React.useState(1);\n    \n    // Sample data points\n    const data = [\n      { x: 1, y: 2 },\n      { x: 2, y: 4 },\n      { x: 3, y: 5 },\n      { x: 4, y: 4 },\n      { x: 5, y: 5 }\n    ];\n    \n    // Calculate predictions and error\n    const predictions = data.map(point => slope * point.x + intercept);\n    const errors = data.map((point, i) => Math.abs(point.y - predictions[i]));\n    const totalError = errors.reduce((sum, err) => sum + err, 0);\n    \n    return (\n      <div className=\"p-4 border border-gray-300 rounded-md bg-gray-50\">\n        <h3 className=\"text-lg font-medium mb-4\">Linear Regression Interactive Demo</h3>\n        \n        <div className=\"mb-4\">\n          <label className=\"block text-sm font-medium mb-1\">\n            Slope: {slope.toFixed(2)}\n          </label>\n          <input\n            type=\"range\"\n            min=\"-2\"\n            max=\"2\"\n            step=\"0.1\"\n            value={slope}\n            onChange={e => setSlope(parseFloat(e.target.value))}\n            className=\"w-full\"\n          />\n        </div>\n        \n        <div className=\"mb-4\">\n          <label className=\"block text-sm font-medium mb-1\">\n            Intercept: {intercept.toFixed(2)}\n          </label>\n          <input\n            type=\"range\"\n            min=\"-5\"\n            max=\"5\"\n            step=\"0.1\"\n            value={intercept}\n            onChange={e => setIntercept(parseFloat(e.target.value))}\n            className=\"w-full\"\n          />\n        </div>\n        \n        <div className=\"mb-4\">\n          <div className=\"h-64 relative border border-gray-300 bg-white\">\n            {/* Coordinate system */}\n            <div className=\"absolute left-0 right-0 bottom-1/2 border-b border-gray-300\"></div>\n            <div className=\"absolute top-0 bottom-0 left-1/2 border-l border-gray-300\"></div>\n            \n            {/* Plot points */}\n            {data.map((point, i) => (\n              <div \n                key={i}\n                className=\"absolute h-2 w-2 bg-blue-500 rounded-full\"\n                style={{ \n                  bottom: \\`\\${(point.y + 5) * 5}%\\`, \n                  left: \\`\\${(point.x + 5) * 5}%\\` \n                }}\n              ></div>\n            ))}\n            \n            {/* Plot line */}\n            <div \n              className=\"absolute h-0.5 bg-red-500 transform origin-left\"\n              style={{ \n                bottom: \\`\\${(intercept + 5) * 5}%\\`, \n                left: '25%',\n                width: '50%',\n                transform: \\`rotate(\\${Math.atan(slope) * (180 / Math.PI)}deg)\\`\n              }}\n            ></div>\n          </div>\n        </div>\n        \n        <div className=\"text-sm\">\n          <p>Equation: y = {slope.toFixed(2)}x + {intercept.toFixed(2)}</p>\n          <p>Total Error: {totalError.toFixed(2)}</p>\n        </div>\n      </div>\n    );\n  }}\n  </InteractiveDemo>\n  \n  ## Advanced Code Example\n  \n  Here's a more complex example showing how to implement a simple neural network for binary classification:\n  \n  \\`\\`\\`javascript\n  class SimpleNeuralNetwork {\n    constructor(inputSize, hiddenSize, outputSize) {\n      // Initialize weights and biases\n      this.weightsInputHidden = Array(inputSize).fill().map(() => \n        Array(hiddenSize).fill().map(() => Math.random() * 2 - 1));\n      this.biasHidden = Array(hiddenSize).fill().map(() => Math.random() * 2 - 1);\n      \n      this.weightsHiddenOutput = Array(hiddenSize).fill().map(() => \n        Array(outputSize).fill().map(() => Math.random() * 2 - 1));\n      this.biasOutput = Array(outputSize).fill().map(() => Math.random() * 2 - 1);\n    }\n    \n    // Sigmoid activation function\n    sigmoid(x) {\n      return 1 / (1 + Math.exp(-x));\n    }\n    \n    // Forward pass\n    predict(inputs) {\n      // Calculate hidden layer outputs\n      const hiddenOutputs = Array(this.biasHidden.length).fill(0);\n      for (let i = 0; i < this.weightsInputHidden.length; i++) {\n        for (let j = 0; j < this.weightsInputHidden[i].length; j++) {\n          hiddenOutputs[j] += inputs[i] * this.weightsInputHidden[i][j];\n        }\n      }\n      \n      for (let i = 0; i < hiddenOutputs.length; i++) {\n        hiddenOutputs[i] = this.sigmoid(hiddenOutputs[i] + this.biasHidden[i]);\n      }\n      \n      // Calculate output layer outputs\n      const outputs = Array(this.biasOutput.length).fill(0);\n      for (let i = 0; i < this.weightsHiddenOutput.length; i++) {\n        for (let j = 0; j < this.weightsHiddenOutput[i].length; j++) {\n          outputs[j] += hiddenOutputs[i] * this.weightsHiddenOutput[i][j];\n        }\n      }\n      \n      for (let i = 0; i < outputs.length; i++) {\n        outputs[i] = this.sigmoid(outputs[i] + this.biasOutput[i]);\n      }\n      \n      return outputs;\n    }\n  }\n  \n  // Example usage\n  const nn = new SimpleNeuralNetwork(2, 3, 1);\n  console.log(\"Prediction for [0, 0]:\", nn.predict([0, 0]));\n  console.log(\"Prediction for [0, 1]:\", nn.predict([0, 1]));\n  console.log(\"Prediction for [1, 0]:\", nn.predict([1, 0]));\n  console.log(\"Prediction for [1, 1]:\", nn.predict([1, 1]));\n  \\`\\`\\`\n  \n  ## Live Code Execution\n  \n  Let's create a component where you can edit and run code directly:\n  \n  <LiveCode initialCode={\n  \\`// Edit and run this code!\n  const data = [1, 2, 3, 4, 5];\n  const doubled = data.map(x => x * 2);\n  const sum = doubled.reduce((a, b) => a + b, 0);\n  console.log(\"Original data:\", data);\n  console.log(\"Doubled:\", doubled);\n  console.log(\"Sum of doubled values:\", sum);\n  \\`}/>\n  \n  ## Conclusion\n  \n  Interactive examples make learning complex concepts much easier. By playing with parameters and seeing results in real-time, you can build intuition for how algorithms work under the hood.\n  \n  Feel free to experiment with the code examples above, modify them, and see what happens!\n    `\n  };\n  \n  export default post;"],"mappings":"AAAA;AACA,MAAMA,IAAI,GAAG;EACTC,EAAE,EAAE,mCAAmC;EACvCC,KAAK,EAAE,uDAAuD;EAC9DC,WAAW,EAAE,qBAAqB;EAClCC,IAAI,EAAE,YAAY;EAClBC,OAAO,EAAE,qGAAqG;EAC9GC,OAAO,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AAED,eAAeN,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}