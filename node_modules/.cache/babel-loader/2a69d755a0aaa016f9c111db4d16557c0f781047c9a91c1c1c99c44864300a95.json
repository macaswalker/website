{"ast":null,"code":"/**\n * @import {\n *   Comment as HastComment,\n *   Doctype as HastDoctype,\n *   Element as HastElement,\n *   Nodes as HastNodes,\n *   RootContent as HastRootContent,\n *   Root as HastRoot,\n *   Text as HastText,\n * } from 'hast'\n */\n\n/**\n * @callback AfterTransform\n *   Callback called when each node is transformed.\n * @param {Node} domNode\n *   DOM node that was handled.\n * @param {HastNodes} hastNode\n *   Corresponding hast node.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef Options\n *   Configuration.\n * @property {AfterTransform | null | undefined} [afterTransform]\n *   Callback called when each node is transformed (optional).\n */\n\nimport { h, s } from 'hastscript';\nimport { webNamespaces } from 'web-namespaces';\n\n/**\n * Transform a DOM tree to a hast tree.\n *\n * @param {Node} tree\n *   DOM tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   Equivalent hast node.\n */\nexport function fromDom(tree, options) {\n  return transform(tree, options || {}) || {\n    type: 'root',\n    children: []\n  };\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n *\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\n */\nfunction transform(node, options) {\n  const transformed = one(node, options);\n  if (transformed && options.afterTransform) options.afterTransform(node, transformed);\n  return transformed;\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n */\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1 /* Element */:\n      {\n        const domNode = /** @type {Element} */node;\n        return element(domNode, options);\n      }\n\n    // Ignore: Attr (2).\n\n    case 3 /* Text */:\n      {\n        const domNode = /** @type {Text} */node;\n        return text(domNode);\n      }\n\n    // Ignore: CDATA (4).\n    // Removed: Entity reference (5)\n    // Removed: Entity (6)\n    // Ignore: Processing instruction (7).\n\n    case 8 /* Comment */:\n      {\n        const domNode = /** @type {Comment} */node;\n        return comment(domNode);\n      }\n    case 9 /* Document */:\n      {\n        const domNode = /** @type {Document} */node;\n        return root(domNode, options);\n      }\n    case 10 /* Document type */:\n      {\n        return doctype();\n      }\n    case 11 /* Document fragment */:\n      {\n        const domNode = /** @type {DocumentFragment} */node;\n        return root(domNode, options);\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document | DocumentFragment} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastRoot}\n *   Equivalent hast node.\n */\nfunction root(node, options) {\n  return {\n    type: 'root',\n    children: all(node, options)\n  };\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n *   Equivalent hast node.\n */\nfunction doctype() {\n  return {\n    type: 'doctype'\n  };\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   DOM node to transform.\n * @returns {HastText}\n *   Equivalent hast node.\n */\nfunction text(node) {\n  return {\n    type: 'text',\n    value: node.nodeValue || ''\n  };\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n *   DOM node to transform.\n * @returns {HastComment}\n *   Equivalent hast node.\n */\nfunction comment(node) {\n  return {\n    type: 'comment',\n    value: node.nodeValue || ''\n  };\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastElement}\n *   Equivalent hast node.\n */\nfunction element(node, options) {\n  const space = node.namespaceURI;\n  const x = space === webNamespaces.svg ? s : h;\n  const tagName = space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName;\n  /** @type {DocumentFragment | Element} */\n  const content =\n  // @ts-expect-error: DOM types are wrong, content can exist.\n  space === webNamespaces.html && tagName === 'template' ? node.content : node;\n  const attributes = node.getAttributeNames();\n  /** @type {Record<string, string>} */\n  const properties = {};\n  let index = -1;\n  while (++index < attributes.length) {\n    properties[attributes[index]] = node.getAttribute(attributes[index]) || '';\n  }\n  return x(tagName, properties, all(content, options));\n}\n\n/**\n * Transform child nodes in a parent.\n *\n * @param {Document | DocumentFragment | Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {Array<HastRootContent>}\n *   Equivalent hast nodes.\n */\nfunction all(node, options) {\n  const nodes = node.childNodes;\n  /** @type {Array<HastRootContent>} */\n  const children = [];\n  let index = -1;\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options);\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child);\n    }\n  }\n  return children;\n}","map":{"version":3,"names":["h","s","webNamespaces","fromDom","tree","options","transform","type","children","node","transformed","one","afterTransform","nodeType","domNode","element","text","comment","root","doctype","undefined","all","value","nodeValue","space","namespaceURI","x","svg","tagName","html","toLowerCase","content","attributes","getAttributeNames","properties","index","length","getAttribute","nodes","childNodes","child","push"],"sources":["/Users/mac/Documents/Career/Website/node_modules/hast-util-from-dom/lib/index.js"],"sourcesContent":["/**\n * @import {\n *   Comment as HastComment,\n *   Doctype as HastDoctype,\n *   Element as HastElement,\n *   Nodes as HastNodes,\n *   RootContent as HastRootContent,\n *   Root as HastRoot,\n *   Text as HastText,\n * } from 'hast'\n */\n\n/**\n * @callback AfterTransform\n *   Callback called when each node is transformed.\n * @param {Node} domNode\n *   DOM node that was handled.\n * @param {HastNodes} hastNode\n *   Corresponding hast node.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef Options\n *   Configuration.\n * @property {AfterTransform | null | undefined} [afterTransform]\n *   Callback called when each node is transformed (optional).\n */\n\nimport {h, s} from 'hastscript'\nimport {webNamespaces} from 'web-namespaces'\n\n/**\n * Transform a DOM tree to a hast tree.\n *\n * @param {Node} tree\n *   DOM tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   Equivalent hast node.\n */\nexport function fromDom(tree, options) {\n  return transform(tree, options || {}) || {type: 'root', children: []}\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n *\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\n */\nfunction transform(node, options) {\n  const transformed = one(node, options)\n  if (transformed && options.afterTransform)\n    options.afterTransform(node, transformed)\n  return transformed\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n */\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1 /* Element */: {\n      const domNode = /** @type {Element} */ (node)\n      return element(domNode, options)\n    }\n\n    // Ignore: Attr (2).\n\n    case 3 /* Text */: {\n      const domNode = /** @type {Text} */ (node)\n      return text(domNode)\n    }\n\n    // Ignore: CDATA (4).\n    // Removed: Entity reference (5)\n    // Removed: Entity (6)\n    // Ignore: Processing instruction (7).\n\n    case 8 /* Comment */: {\n      const domNode = /** @type {Comment} */ (node)\n      return comment(domNode)\n    }\n\n    case 9 /* Document */: {\n      const domNode = /** @type {Document} */ (node)\n      return root(domNode, options)\n    }\n\n    case 10 /* Document type */: {\n      return doctype()\n    }\n\n    case 11 /* Document fragment */: {\n      const domNode = /** @type {DocumentFragment} */ (node)\n      return root(domNode, options)\n    }\n\n    default: {\n      return undefined\n    }\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document | DocumentFragment} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastRoot}\n *   Equivalent hast node.\n */\nfunction root(node, options) {\n  return {type: 'root', children: all(node, options)}\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n *   Equivalent hast node.\n */\nfunction doctype() {\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   DOM node to transform.\n * @returns {HastText}\n *   Equivalent hast node.\n */\nfunction text(node) {\n  return {type: 'text', value: node.nodeValue || ''}\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n *   DOM node to transform.\n * @returns {HastComment}\n *   Equivalent hast node.\n */\nfunction comment(node) {\n  return {type: 'comment', value: node.nodeValue || ''}\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastElement}\n *   Equivalent hast node.\n */\nfunction element(node, options) {\n  const space = node.namespaceURI\n  const x = space === webNamespaces.svg ? s : h\n  const tagName =\n    space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName\n  /** @type {DocumentFragment | Element} */\n  const content =\n    // @ts-expect-error: DOM types are wrong, content can exist.\n    space === webNamespaces.html && tagName === 'template' ? node.content : node\n  const attributes = node.getAttributeNames()\n  /** @type {Record<string, string>} */\n  const properties = {}\n  let index = -1\n\n  while (++index < attributes.length) {\n    properties[attributes[index]] = node.getAttribute(attributes[index]) || ''\n  }\n\n  return x(tagName, properties, all(content, options))\n}\n\n/**\n * Transform child nodes in a parent.\n *\n * @param {Document | DocumentFragment | Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {Array<HastRootContent>}\n *   Equivalent hast nodes.\n */\nfunction all(node, options) {\n  const nodes = node.childNodes\n  /** @type {Array<HastRootContent>} */\n  const children = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options)\n\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child)\n    }\n  }\n\n  return children\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}